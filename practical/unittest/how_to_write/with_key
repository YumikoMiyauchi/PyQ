import unittest


from converter import list_to_dict
def test__with_key(self):
        """key="code"を指定してcodeの値をキーにする場合"""
        actual = list_to_dict(
        [{'code':'Val','name':'ロッシ'},
         {'code':'Mar','name':'マルクス'},
         {'code':'Lor','name':'ロレンソ'}],
        key='code'
        )
        self.assertEqual(actual,{
        'Val':{'code':'Val','name':'ロッシ'},
        'Mar':{'code':'Mar','name':'マルクス'},
        'Lor':{'code':'Lor','name':'ロレンソ'}
        })
        
        
        うまくテストを構造化するコツ

1テスト対象、1 TestCase クラス

1関数、1クラスを1つの テスト対象 として、それごとに1テストケース（TestCase クラス）を作ります。
今回は list_to_dict 1関数のために TestListToDict 1クラスを作っています。
list_to_dict の1つの「場合」の確認に、1つのテストメソッド test_... を作っています。

テストケースのクラス名はなんでも良いですが class TestListToDict のように、関数名を入れておくと分かりやすいです。
テストメソッドも、確認しているケースに応じた名前にします。「デフォルトの引数のない場合」「引数のある場合」などです。

1テストケース内で複数の関数やクラスの動作確認をしても動作上は問題ありません。
しかし、後で見たときに「このテストケース、一体何を確認しようとしてるんだ」と混乱することがよくあります。
なので、1テスト対象につき、1テストケースを用意しましょう。



1テストメソッドごとに1つ「確認」

1テストメソッド def test_ ごとに1回テスト対象を呼びます。
このテストケースの場合 test__default_key, test__with_key と2つあって、それぞれ1回ずつ list_to_dict を呼んでいます。


確認する流れは以下です

前提の用意。データの作成
テスト対象 converter 関数の呼び出し
返り値や、他に変更された値が正しいか確認
「入力 => テスト対象 => 出力」つまり「テスト対象の入出力」が何であるかを常に意識してテストを書きましょう。
そうすれば混乱のないキレイなテストが書けます。



データは共通化しすぎない

テストに使うデータは共通化しすぎないほうが良いです。
たとえば list_to_dict に渡している値をグローバル変数において各テストメソッドで使い回すこともできますが、やめましょう。

共通化したデータを変更するとすべてのテストメソッドに影響が出る
リストや辞書は値が書き変えれるので、あるテストメソッドが他のテストメソッドの操作に影響されるおそれがある
共通化したデータ中のどの部分が、それぞれのテストメソッドにとって重要な値なのかが分かりにくい
test__with_key の場合 code キーがある代わりに id キーがないので、「このテストメソッドでは code キーが重要」と自明になります。



テストケース全体で前提になる値や全体で必要になる処理は共通化しても良いです。
setUpメソッドを作ると各 test_ メソッド実行前に実行されるので、テストに必要なデータを揃えれます。tearDownメソッドを作ると各テストメソッド実行後に実行されます。

class TestSome(unittest.TestCase):
    def setUp(self):
        ...

    def tearDown(self):
        ...
