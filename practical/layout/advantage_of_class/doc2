さらに追加の仕様がきました。
商品クラスとして分離したことで「変更に強い設計」になったことを体感しましょう。



追加仕様2

商品マスターデータに「カテゴリーID」という値が追加されました。
この「カテゴリーID」と「カテゴリー名」を売上データのCSVに追加してください。

カテゴリーとは

「カテゴリーID」はカテゴリー「食品」や「ホビー」を表す一意な値です。

カテゴリーID: 商品の「カテゴリー」ごとに一意な値
カテゴリーのIDと名前のマッピング（対応表）は以下になります。

1: 家電
2: パソコン
3: キッチン用品
4: 食品
5: ホビー
6: 本
売上データへの変更

カテゴリーIDと、カテゴリーIDから取得したカテゴリー名を売上データに追加してください。
売上データのCSVは以下のような順序になります。

購入ID,ユーザーID,商品ID,商品名,商品価格,商品価格（税込み）,商品カテゴリーID,商品カテゴリー名,個数,購入日時



プログラムの変更

カテゴリーIDからカテゴリー名を取得する処理を Item クラスに追加して、売上データにカテゴリーIDとカテゴリー名を追加しましょう。
カテゴリーIDと名前のマッピングはひとまず辞書として item.py に置いておきます。






カテゴリーの仕様追加にも Item クラスは簡単に対応できました。

どうしてクラスに書くの？

もし Item クラスがない場合「カテゴリーIDからカテゴリー名を取得する処理」はどこに置くべきでしょうか。
たとえば ITEM_CATEGORY を main.py に置いて、売上生データを売上データに変換している処理内でカテゴリー名を取得しても良さそうです。

ITEM_CATEGORY = {
    '1': '家電',
    ...
}

def main():
    ...

    # 商品の情報を追加する
    sales = []
    for row in sales_raw:
        if row['item_id'] in items:
            ...
            # カテゴリーの値を追加
            category_id = items[row['item_id']]['category_id']
            row['item_category_id'] = category_id
            row['item_category_name'] = ITEM_CATEGORY.get(category_id, 'カテゴリーなし')

これでも問題はありません。
ですが「商品のカテゴリーIDをカテゴリー名に変換する」という「商品」についての処理が main.py 内に置かれてしまいます。
「商品マスターデータ」に関する処理は item.py にまとめるほうが読みやすいですし、再利用もしやすいでしょう。

では item.py 内で関数にしておくのはどうでしょう。

ITEM_CATEGORY = {
    '1': '家電',
    ...
}


def read_items():
    ...


def get_category_name(category_id):
    return ITEM_CATEGORY.get(category_id, 'カテゴリーなし')

この get_category_name 関数を main.py で import して使うのも良いでしょう。

ですがここでは「カテゴリー名を取得する」という処理はどのみち「商品」というモノに対してしか使われません。
このためクラス（データと処理をまとめたもの）にまとめておくと使い勝手が良くなります。

item = Item("1", "商品名", 300, "1")
print(item.category_id)  # 1と表示
print(item.get_category_name())  # 家電と表示

将来的にもし「カテゴリー」というモノが「商品」以外のモノにも使われる場合や、カテゴリーに関する他の処理が増える場合、 Category クラスを作ったり category.py Pythonファイルに処理を分割しても良いでしょう。
「消費税計算」の処理も「商品」以外に関係する場合、他に分離することも考えられます。
ただ今回の場合はそこまでは想定しないので、 item.py 内に処理を置きました。





コラム: どうして設計が必要なの？「保守性が高い」プログラムを書く必要があるの？

プログラムを開発していく中で仕様が追加されることはよくあります。
開発中にやりたいことが増えたり、変わったりします。プログラムが使われている間でもバグを修正したり、新しい機能を追加する必要があります。

よくアプリケーションやゲームでも「バージョン3.1」などのような言葉を聞いたことがあります。
これはプログラムがどんどんアップデートされているためですね。そのためにもプログラムはどんどん変わっていく必要があります。

こういった変更に容易に対応できるプログラムや設計を「保守性が高い」と呼ぶことがあります。
他にも「変更に強い」「メンテナンス性が高い」とも呼びます。
変更に強い設計をしておくことで価値あるプログラムを作るスピードが格段に上がります 。

この「設計」パートの最初のころを考えてみましょう。
1つの関数内に、すべてのブロックが入れ子になって処理が書かれていました。
何をしているのか、どこをどう修正すればいいかも分からない状態だったでしょう。
少しの変更で全体の処理が壊れてしまうような「脆さ」がありました。これは変更に弱い、保守性の低いプログラムと言えます。

ですが今では比較的容易に変更できます。
それはこの「設計」パートを通してプログラムの可読性を上げ、関数を分離していくなかでプログラムが「保守性が高い」「変更に強い」プログラムに成長できたからです。
少しの変更のためにプログラムの奥深く、プログラムの全体を変更するのはとても大変です。
保守性の高いプログラムを書くことで、新しい価値をどんどん生み出せるようにしておきましょう。
